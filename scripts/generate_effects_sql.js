const fs = require('fs');
const path = require('path');

function toTitleCase(str) {
    return str.replace(/\w\S*/g, function (txt) { return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase(); });
}

function generateSQL() {
    console.log('--- Generating SQL for Special Effects Import ---');

    const csvPath = path.resolve(__dirname, '../special_effects_import.csv');
    if (!fs.existsSync(csvPath)) {
        console.error('CSV file not found!');
        return;
    }

    const content = fs.readFileSync(csvPath, 'utf8');
    const lines = content.split('\n');

    // Collect all unique effects
    const allEffects = new Set();
    const productUpdates = [];

    // Skip header
    const startIdx = lines[0].toLowerCase().includes('sku') ? 1 : 0;

    for (let i = startIdx; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        // Handle CSV parsing (simple split by first comma)
        const firstComma = line.indexOf(',');
        if (firstComma === -1) continue;

        const sku = line.substring(0, firstComma).trim();
        const rawEffects = line.substring(firstComma + 1).trim();

        if (!rawEffects) continue;

        // Split effects by pipe OR comma if pipe not found? 
        // User instruction was pipe. Let's assume pipe.
        // But some users might use comma inside the text if they misunderstood. 
        // We will stick to pipe '|' as separator for effects.

        const effectNames = rawEffects.split('|').map(e => {
            let name = e.trim();
            // Basic normalization: Title Case to match DB likely
            return toTitleCase(name);
        }).filter(e => e.length > 0);

        if (effectNames.length > 0) {
            effectNames.forEach(e => allEffects.add(e));
            productUpdates.push({ sku, effects: effectNames });
        }
    }

    // Generate SQL Content
    const sqlLines = [];
    sqlLines.push('-- Generated by Antigravity');
    sqlLines.push('-- 1. Insert missing special effects');

    allEffects.forEach(effectName => {
        // Safe string escaping for SQL: single quote -> two single quotes
        const safeName = effectName.replace(/'/g, "''");
        sqlLines.push(`INSERT INTO "special_effects" ("name") SELECT '${safeName}' WHERE NOT EXISTS (SELECT 1 FROM "special_effects" WHERE "name" ILIKE '${safeName}');`);
    });

    sqlLines.push('\n-- 2. Update Products');

    productUpdates.forEach(p => {
        const safeSku = p.sku.replace(/'/g, "''");

        // Construct the subquery for the ID concatenation
        // using array_to_string and array_agg for cleaner syntax? 
        // Or string concat || 
        // Let's use string_agg or simple cast.

        // Format: (SELECT id FROM special_effects WHERE name ILIKE 'Name' LIMIT 1)::text

        const selectParts = p.effects.map(eff => {
            const safeEff = eff.replace(/'/g, "''");
            return `(SELECT "id"::text FROM "special_effects" WHERE "name" ILIKE '${safeEff}' LIMIT 1)`;
        });

        const concatQuery = selectParts.join(" || '|' || ");

        sqlLines.push(`UPDATE "products" SET "special_effects" = ${concatQuery} WHERE "sku" = '${safeSku}';`);
    });

    const outFile = path.resolve(__dirname, '../import_effects.sql');
    fs.writeFileSync(outFile, sqlLines.join('\n'));

    console.log(`Successfully generated SQL script at: ${outFile}`);
    console.log(`Found ${allEffects.size} unique effects.`);
    console.log(`Planned updates for ${productUpdates.length} products.`);
}

generateSQL();
